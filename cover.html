
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>keeper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/quicksilver-zone/quicksilver/x/claimsmanager/keeper/abci.go (0.0%)</option>
				
				<option value="file1">github.com/quicksilver-zone/quicksilver/x/claimsmanager/keeper/claims.go (71.6%)</option>
				
				<option value="file2">github.com/quicksilver-zone/quicksilver/x/claimsmanager/keeper/grpc_query.go (89.1%)</option>
				
				<option value="file3">github.com/quicksilver-zone/quicksilver/x/claimsmanager/keeper/hooks.go (77.8%)</option>
				
				<option value="file4">github.com/quicksilver-zone/quicksilver/x/claimsmanager/keeper/keeper.go (52.6%)</option>
				
				<option value="file5">github.com/quicksilver-zone/quicksilver/x/claimsmanager/keeper/msg_server.go (100.0%)</option>
				
				<option value="file6">github.com/quicksilver-zone/quicksilver/x/claimsmanager/keeper/self_consensus_state.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
)

// BeginBlocker of claimsmanager module.
func (k Keeper) BeginBlocker(_ sdk.Context) {<span class="cov8" title="1">
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package keeper

import (
        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/quicksilver-zone/quicksilver/x/claimsmanager/types"
)

// GetClaim returns claim.
func (k Keeper) GetClaim(ctx sdk.Context, chainID, address string, module types.ClaimType, srcChainID string) (types.Claim, bool) <span class="cov8" title="1">{
        data := types.Claim{}
        store := prefix.NewStore(ctx.KVStore(k.storeKey), nil)
        key := types.GetKeyClaim(chainID, address, module, srcChainID)
        bz := store.Get(key)
        if len(bz) == 0 </span><span class="cov8" title="1">{
                return data, false
        }</span>

        <span class="cov8" title="1">k.cdc.MustUnmarshal(bz, &amp;data)
        return data, true</span>
}

// GetLastEpochClaim returns claim from last epoch.
func (k Keeper) GetLastEpochClaim(ctx sdk.Context, chainID, address string, module types.ClaimType, srcChainID string) (types.Claim, bool) <span class="cov8" title="1">{
        data := types.Claim{}
        store := prefix.NewStore(ctx.KVStore(k.storeKey), nil)
        key := types.GetKeyLastEpochClaim(chainID, address, module, srcChainID)
        bz := store.Get(key)
        if len(bz) == 0 </span><span class="cov8" title="1">{
                return data, false
        }</span>

        <span class="cov8" title="1">k.cdc.MustUnmarshal(bz, &amp;data)
        return data, true</span>
}

// SetClaim sets claim.
func (k Keeper) SetClaim(ctx sdk.Context, claim *types.Claim) <span class="cov8" title="1">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), nil)
        bz := k.cdc.MustMarshal(claim)
        store.Set(types.GetKeyClaim(claim.ChainId, claim.UserAddress, claim.Module, claim.SourceChainId), bz)
}</span>

// SetLastEpochClaim sets claim for last epoch.
func (k Keeper) SetLastEpochClaim(ctx sdk.Context, claim *types.Claim) <span class="cov8" title="1">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), nil)
        bz := k.cdc.MustMarshal(claim)
        store.Set(types.GetKeyLastEpochClaim(claim.ChainId, claim.UserAddress, claim.Module, claim.SourceChainId), bz)
}</span>

// DeleteClaim deletes claim.
func (k Keeper) DeleteClaim(ctx sdk.Context, claim *types.Claim) <span class="cov8" title="1">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), nil)
        store.Delete(types.GetKeyClaim(claim.ChainId, claim.UserAddress, claim.Module, claim.SourceChainId))
}</span>

// DeleteLastEpochClaim deletes claim for last epoch.
func (k Keeper) DeleteLastEpochClaim(ctx sdk.Context, claim *types.Claim) <span class="cov8" title="1">{
        store := prefix.NewStore(ctx.KVStore(k.storeKey), nil)
        store.Delete(types.GetKeyLastEpochClaim(claim.ChainId, claim.UserAddress, claim.Module, claim.SourceChainId))
}</span>

// IterateClaims iterates through zone claims.
func (k Keeper) IterateClaims(ctx sdk.Context, chainID string, fn func(index int64, data types.Claim) (stop bool)) <span class="cov8" title="1">{
        // noop
        if fn == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetPrefixClaim(chainID))
        defer iterator.Close()

        i := int64(0)
        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                data := types.Claim{}
                k.cdc.MustUnmarshal(iterator.Value(), &amp;data)
                stop := fn(i, data)
                if stop </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">i++</span>
        }
}

// IterateUserClaims iterates through zone claims for a given address.
func (k Keeper) IterateUserClaims(ctx sdk.Context, chainID, address string, fn func(index int64, data types.Claim) (stop bool)) <span class="cov0" title="0">{
        // noop
        if fn == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetPrefixUserClaim(chainID, address))
        defer iterator.Close()

        i := int64(0)
        for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                data := types.Claim{}
                k.cdc.MustUnmarshal(iterator.Value(), &amp;data)
                stop := fn(i, data)
                if stop </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">i++</span>
        }
}

// IterateLastEpochClaims iterates through zone claims from last epoch.
func (k Keeper) IterateLastEpochClaims(ctx sdk.Context, chainID string, fn func(index int64, data types.Claim) (stop bool)) <span class="cov8" title="1">{
        // noop
        if fn == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetPrefixLastEpochClaim(chainID))
        defer iterator.Close()

        i := int64(0)
        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                data := types.Claim{}
                k.cdc.MustUnmarshal(iterator.Value(), &amp;data)
                stop := fn(i, data)
                if stop </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">i++</span>
        }
}

// IterateLastEpochUserClaims iterates through zone claims from last epoch for a given user.
func (k Keeper) IterateLastEpochUserClaims(ctx sdk.Context, chainID, address string, fn func(index int64, data types.Claim) (stop bool)) <span class="cov0" title="0">{
        // noop
        if fn == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetPrefixLastEpochUserClaim(chainID, address))
        defer iterator.Close()

        i := int64(0)
        for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                data := types.Claim{}
                k.cdc.MustUnmarshal(iterator.Value(), &amp;data)
                stop := fn(i, data)
                if stop </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">i++</span>
        }
}

// IterateAllLastEpochClaims iterates through zone claims from last epoch for a given user.
func (k Keeper) IterateAllLastEpochClaims(ctx sdk.Context, fn func(index int64, key []byte, data types.Claim) (stop bool)) <span class="cov8" title="1">{
        // noop
        if fn == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.KeyPrefixLastEpochClaim)
        defer iterator.Close()

        i := int64(0)
        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                data := types.Claim{}
                k.cdc.MustUnmarshal(iterator.Value(), &amp;data)
                stop := fn(i, iterator.Key(), data)
                if stop </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">i++</span>
        }
}

// IterateAllClaims iterates through all claims.
func (k Keeper) IterateAllClaims(ctx sdk.Context, fn func(index int64, key []byte, data types.Claim) (stop bool)) <span class="cov8" title="1">{
        // noop
        if fn == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.KeyPrefixClaim)
        defer iterator.Close()

        i := int64(0)
        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                data := types.Claim{}
                k.cdc.MustUnmarshal(iterator.Value(), &amp;data)
                stop := fn(i, iterator.Key(), data)
                if stop </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">i++</span>
        }
}

// AllClaims returns a slice containing all claims from the store.
func (k Keeper) AllClaims(ctx sdk.Context) []*types.Claim <span class="cov8" title="1">{
        var claims []*types.Claim

        store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.KeyPrefixClaim)
        defer iterator.Close()

        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                claim := types.Claim{}
                k.cdc.MustUnmarshal(iterator.Value(), &amp;claim)

                claims = append(claims, &amp;claim)
        }</span>

        <span class="cov8" title="1">return claims</span>
}

func (k Keeper) AllZoneClaims(ctx sdk.Context, chainID string) []*types.Claim <span class="cov8" title="1">{
        var claims []*types.Claim
        k.IterateClaims(ctx, chainID, func(_ int64, claim types.Claim) (stop bool) </span><span class="cov8" title="1">{
                claims = append(claims, &amp;claim)
                return false
        }</span>)
        <span class="cov8" title="1">return claims</span>
}

func (k Keeper) AllZoneUserClaims(ctx sdk.Context, chainID, address string) []*types.Claim <span class="cov0" title="0">{
        var claims []*types.Claim
        k.IterateUserClaims(ctx, chainID, address, func(_ int64, claim types.Claim) (stop bool) </span><span class="cov0" title="0">{
                claims = append(claims, &amp;claim)
                return false
        }</span>)
        <span class="cov0" title="0">return claims</span>
}

func (k Keeper) AllZoneLastEpochClaims(ctx sdk.Context, chainID string) []*types.Claim <span class="cov8" title="1">{
        var claims []*types.Claim
        k.IterateLastEpochClaims(ctx, chainID, func(_ int64, claim types.Claim) (stop bool) </span><span class="cov8" title="1">{
                claims = append(claims, &amp;claim)
                return false
        }</span>)
        <span class="cov8" title="1">return claims</span>
}

func (k Keeper) AllZoneLastEpochUserClaims(ctx sdk.Context, chainID, address string) []*types.Claim <span class="cov0" title="0">{
        var claims []*types.Claim
        k.IterateLastEpochUserClaims(ctx, chainID, address, func(_ int64, claim types.Claim) (stop bool) </span><span class="cov0" title="0">{
                claims = append(claims, &amp;claim)
                return false
        }</span>)
        <span class="cov0" title="0">return claims</span>
}

// ClearClaims deletes all the current epoch claims of the given zone.
func (k Keeper) ClearClaims(ctx sdk.Context, chainID string) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetPrefixClaim(chainID))
        defer iterator.Close()

        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                key := iterator.Key()
                store.Delete(key)
        }</span>
}

// ClearLastEpochClaims deletes all the last epoch claims of the given zone.
func (k Keeper) ClearLastEpochClaims(ctx sdk.Context, chainID string) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetPrefixLastEpochClaim(chainID))
        defer iterator.Close()

        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                key := iterator.Key()
                store.Delete(key)
        }</span>
}

// ArchiveAndGarbageCollectClaims deletes all the last epoch claims and moves the current epoch claims to the last epoch store.
func (k Keeper) ArchiveAndGarbageCollectClaims(ctx sdk.Context, chainID string) <span class="cov8" title="1">{
        k.ClearLastEpochClaims(ctx, chainID)

        store := ctx.KVStore(k.storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetPrefixClaim(chainID))
        defer iterator.Close()

        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                key := iterator.Key()
                store.Delete(key)
                newKey := types.KeyPrefixLastEpochClaim
                newKey = append(newKey, key[1:]...) // update prefix from KeyPrefixClaim to KeyPrefixLastEpochClaim
                store.Set(newKey, iterator.Value())
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package keeper

import (
        "bytes"
        "context"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/cosmos/cosmos-sdk/store/prefix"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/query"

        "github.com/quicksilver-zone/quicksilver/x/claimsmanager/types"
)

var _ types.QueryServer = Keeper{}

func (k Keeper) Claims(c context.Context, req *types.QueryClaimsRequest) (*types.QueryClaimsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "empty request")
        }</span>

        <span class="cov8" title="1">ctx := sdk.UnwrapSDKContext(c)

        var claims []types.Claim
        store := prefix.NewStore(ctx.KVStore(k.storeKey), types.KeyPrefixClaim)

        pageRes, err := query.FilteredPaginate(store, req.Pagination, func(_, value []byte, accumulate bool) (bool, error) </span><span class="cov8" title="1">{
                var claim types.Claim
                if err := k.cdc.Unmarshal(value, &amp;claim); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">if claim.ChainId == req.ChainId </span><span class="cov8" title="1">{
                        claims = append(claims, claim)
                        return true, nil
                }</span>

                <span class="cov8" title="1">return false, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;types.QueryClaimsResponse{
                Claims:     claims,
                Pagination: pageRes,
        }, nil</span>
}

func (k Keeper) LastEpochClaims(c context.Context, q *types.QueryClaimsRequest) (*types.QueryClaimsResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(c)
        out := []types.Claim{}

        k.IterateLastEpochClaims(ctx, q.ChainId, func(_ int64, claim types.Claim) (stop bool) </span><span class="cov8" title="1">{
                out = append(out, claim)
                return false
        }</span>)

        <span class="cov8" title="1">return &amp;types.QueryClaimsResponse{Claims: out}, nil</span>
}

func (k Keeper) UserClaims(c context.Context, q *types.QueryClaimsRequest) (*types.QueryClaimsResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(c)
        out := []types.Claim{}

        addrBytes := []byte(q.Address)

        k.IterateAllClaims(ctx, func(_ int64, key []byte, claim types.Claim) (stop bool) </span><span class="cov8" title="1">{
                // The assumption is that IterateAllClaims returns non-empty keys.
                // check for the presence of the addr bytes in the key.
                // first prefix byte is 0x00; so cater for that!
                idx := bytes.Index(key[1:], []byte{0x00})
                if idx &lt; 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">idx += 1 + 1 // add + 1 to skip the separator.

                if bytes.Equal(key[idx:idx+len(addrBytes)], addrBytes) </span><span class="cov8" title="1">{
                        out = append(out, claim)
                }</span>
                <span class="cov8" title="1">return false</span>
        })
        <span class="cov8" title="1">return &amp;types.QueryClaimsResponse{Claims: out}, nil</span>
}

func (k Keeper) UserLastEpochClaims(c context.Context, q *types.QueryClaimsRequest) (*types.QueryClaimsResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(c)
        out := []types.Claim{}

        addrBytes := []byte(q.Address)
        k.IterateAllLastEpochClaims(ctx, func(_ int64, key []byte, claim types.Claim) (stop bool) </span><span class="cov8" title="1">{
                // check for the presence of the addr bytes in the key.
                idx := bytes.Index(key, []byte{0x00})
                if idx &lt; 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                // First byte was 0x01, so no need to consider it; + 1 to skip the separator.
                <span class="cov8" title="1">idx++

                if bytes.Equal(key[idx:idx+len(addrBytes)], addrBytes) </span><span class="cov8" title="1">{
                        out = append(out, claim)
                }</span>
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return &amp;types.QueryClaimsResponse{Claims: out}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"

        epochstypes "github.com/quicksilver-zone/quicksilver/x/epochs/types"
)

func (k Keeper) BeforeEpochStart(ctx sdk.Context, epochIdentifier string, epochNumber int64) error <span class="cov8" title="1">{
        if epochIdentifier == epochstypes.EpochIdentifierEpoch &amp;&amp; epochNumber &gt; 1 </span><span class="cov8" title="1">{
                if err := k.StoreSelfConsensusState(ctx, "epoch"); err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Error("unable to store consensus state", "error", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (k Keeper) AfterEpochEnd(_ sdk.Context, _ string, _ int64) error <span class="cov8" title="1">{
        return nil
}</span>

// ___________________________________________________________________________________________________

// Hooks wrapper struct for incentives keeper.
type Hooks struct {
        k Keeper
}

var _ epochstypes.EpochHooks = Hooks{}

func (k Keeper) Hooks() Hooks <span class="cov8" title="1">{
        return Hooks{k}
}</span>

// epochs hooks.
func (h Hooks) BeforeEpochStart(ctx sdk.Context, epochIdentifier string, epochNumber int64) error <span class="cov8" title="1">{
        return h.k.BeforeEpochStart(ctx, epochIdentifier, epochNumber)
}</span>

func (h Hooks) AfterEpochEnd(ctx sdk.Context, epochIdentifier string, epochNumber int64) error <span class="cov8" title="1">{
        return h.k.AfterEpochEnd(ctx, epochIdentifier, epochNumber)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package keeper

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/tendermint/tendermint/libs/log"

        "github.com/cosmos/cosmos-sdk/codec"
        storetypes "github.com/cosmos/cosmos-sdk/store/types"
        sdk "github.com/cosmos/cosmos-sdk/types"

        ibcclienttypes "github.com/cosmos/ibc-go/v6/modules/core/02-client/types"
        ibckeeper "github.com/cosmos/ibc-go/v6/modules/core/keeper"
        ibctmtypes "github.com/cosmos/ibc-go/v6/modules/light-clients/07-tendermint/types"

        "github.com/quicksilver-zone/quicksilver/x/claimsmanager/types"
)

type Keeper struct {
        cdc       codec.BinaryCodec
        storeKey  storetypes.StoreKey
        IBCKeeper *ibckeeper.Keeper
}

// NewKeeper returns a new instance of participationrewards Keeper.
// This function will panic on failure.
func NewKeeper(
        cdc codec.Codec,
        key storetypes.StoreKey,
        ibcKeeper *ibckeeper.Keeper,
) Keeper <span class="cov8" title="1">{
        if ibcKeeper == nil </span><span class="cov0" title="0">{
                panic("ibcKeeper is nil")</span>
        }

        <span class="cov8" title="1">return Keeper{
                cdc:       cdc,
                storeKey:  key,
                IBCKeeper: ibcKeeper,
        }</span>
}

// Logger returns a module-specific logger.
func (k Keeper) Logger(ctx sdk.Context) log.Logger <span class="cov0" title="0">{
        return ctx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
}</span>

func (k Keeper) StoreSelfConsensusState(ctx sdk.Context, key string) error <span class="cov8" title="1">{
        var height ibcclienttypes.Height
        if strings.Contains(ctx.ChainID(), "-") </span><span class="cov0" title="0">{
                revisionNum, err := strconv.ParseUint(strings.Split(ctx.ChainID(), "-")[1], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        k.Logger(ctx).Error("Error getting revision number for client ")
                        return err
                }</span>

                <span class="cov0" title="0">height = ibcclienttypes.Height{
                        RevisionNumber: revisionNum,
                        RevisionHeight: uint64(ctx.BlockHeight() - 1),
                }</span>
        } else<span class="cov8" title="1"> {
                // ONLY FOR TESTING - ibctesting module chains donot follow standard [chainname]-[num] structure
                height = ibcclienttypes.Height{
                        RevisionNumber: 0, // revision number for testchain1 is 0 (because parseChainId splits on '-')
                        RevisionHeight: uint64(ctx.BlockHeight() - 1),
                }
        }</span>

        <span class="cov8" title="1">selfConsState, err := k.IBCKeeper.ClientKeeper.GetSelfConsensusState(ctx, height)
        if err != nil </span><span class="cov0" title="0">{
                k.Logger(ctx).Error("Error getting self consensus state of previous height")
                return err
        }</span>

        <span class="cov8" title="1">state, _ := selfConsState.(*ibctmtypes.ConsensusState)
        k.SetSelfConsensusState(ctx, key, state)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package keeper

import (
        "github.com/quicksilver-zone/quicksilver/x/claimsmanager/types"
)

type msgServer struct {
        *Keeper
}

// NewMsgServerImpl returns an implementation of the MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: &amp;keeper}
}</span>

var _ types.MsgServer = msgServer{}
</pre>
		
		<pre class="file" id="file6" style="display: none">package keeper

import (
        sdk "github.com/cosmos/cosmos-sdk/types"

        ibctmtypes "github.com/cosmos/ibc-go/v6/modules/light-clients/07-tendermint/types"

        "github.com/quicksilver-zone/quicksilver/x/claimsmanager/types"
)

// GetSelfConsensusState returns consensus state stored every epoch.
func (k Keeper) GetSelfConsensusState(ctx sdk.Context, key string) (ibctmtypes.ConsensusState, bool) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        var selfConsensusState ibctmtypes.ConsensusState

        bz := store.Get(append(types.KeySelfConsensusState, key...))
        if bz == nil </span><span class="cov8" title="1">{
                return selfConsensusState, false
        }</span>
        <span class="cov8" title="1">k.cdc.MustUnmarshal(bz, &amp;selfConsensusState)
        return selfConsensusState, true</span>
}

// SetSelfConsensusState sets the self consensus state.
func (k Keeper) SetSelfConsensusState(ctx sdk.Context, key string, consState *ibctmtypes.ConsensusState) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        store.Set(append(types.KeySelfConsensusState, key...), k.cdc.MustMarshal(consState))
}</span>

// DeleteSelfConsensusState deletes the self consensus state.
func (k Keeper) DeleteSelfConsensusState(ctx sdk.Context, key string) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        store.Delete(append(types.KeySelfConsensusState, key...))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
